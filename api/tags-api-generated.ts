/* tslint:disable */
/* eslint-disable */
/*
Asana

This is the interface for interacting with the [Asana Platform](https://developers.asana.com). Our API reference is generated from our [OpenAPI spec](https://raw.githubusercontent.com/Asana/openapi/master/defs/asana_oas.yaml).

The version of the OpenAPI document: 1.0


NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
import { fromBuffer } from "file-type/browser"
const FormData = require("form-data")
import { setOAuthToObject } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { ErrorResponse } from '../models';
// @ts-ignore
import { TagCreateTagForWorkspaceRequest } from '../models';
// @ts-ignore
import { TagRequest } from '../models';
// @ts-ignore
import { TagsCreateNewTagRecordRequest } from '../models';
// @ts-ignore
import { TagsCreateNewTagRecordResponse } from '../models';
// @ts-ignore
import { TagsCreateTagInWorkspaceRequest } from '../models';
// @ts-ignore
import { TagsCreateTagInWorkspaceResponse } from '../models';
// @ts-ignore
import { TagsGetFilteredTagsResponse } from '../models';
// @ts-ignore
import { TagsGetRecordResponse } from '../models';
// @ts-ignore
import { TagsGetTaskTagsResponse } from '../models';
// @ts-ignore
import { TagsListFilteredTagsResponse } from '../models';
// @ts-ignore
import { TagsRemoveTagResponse } from '../models';
// @ts-ignore
import { TagsUpdateTagRecordResponse } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * TagsApi - axios parameter creator
 * @export
 */
export const TagsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new tag in a workspace or organization.  Every tag is required to be created in a specific workspace or organization, and this cannot be changed once set. Note that you can use the workspace parameter regardless of whether or not it is an organization.  Returns the full record of the newly created tag.
         * @summary Create a tag
         * @param {TagsCreateNewTagRecordRequest} tagsCreateNewTagRecordRequest The tag to create.
         * @param {boolean} [optPretty] Provides “pretty” output. Provides the response in a “pretty” format. In the case of JSON this means doing proper line breaking and indentation to make it readable. This will take extra time and increase the response size so it is advisable only to use this during debugging.
         * @param {Array<'color' | 'created_at' | 'followers' | 'followers.name' | 'name' | 'notes' | 'permalink_url' | 'workspace' | 'workspace.name'>} [optFields] This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewTagRecord: async (tagsCreateNewTagRecordRequest: TagsCreateNewTagRecordRequest, optPretty?: boolean, optFields?: Array<'color' | 'created_at' | 'followers' | 'followers.name' | 'name' | 'notes' | 'permalink_url' | 'workspace' | 'workspace.name'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagsCreateNewTagRecordRequest' is not null or undefined
            assertParamExists('createNewTagRecord', 'tagsCreateNewTagRecordRequest', tagsCreateNewTagRecordRequest)
            const localVarPath = `/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)
            // authentication personalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            if (optPretty !== undefined) {
                localVarQueryParameter['opt_pretty'] = optPretty;
            }

            if (optFields) {
                localVarQueryParameter['opt_fields'] = optFields.join(COLLECTION_FORMATS.csv);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: tagsCreateNewTagRecordRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/tags',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(tagsCreateNewTagRecordRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new tag in a workspace or organization.  Every tag is required to be created in a specific workspace or organization, and this cannot be changed once set. Note that you can use the workspace parameter regardless of whether or not it is an organization.  Returns the full record of the newly created tag.
         * @summary Create a tag in a workspace
         * @param {string} workspaceGid Globally unique identifier for the workspace or organization.
         * @param {TagsCreateTagInWorkspaceRequest} tagsCreateTagInWorkspaceRequest The tag to create.
         * @param {boolean} [optPretty] Provides “pretty” output. Provides the response in a “pretty” format. In the case of JSON this means doing proper line breaking and indentation to make it readable. This will take extra time and increase the response size so it is advisable only to use this during debugging.
         * @param {Array<'color' | 'created_at' | 'followers' | 'followers.name' | 'name' | 'notes' | 'permalink_url' | 'workspace' | 'workspace.name'>} [optFields] This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTagInWorkspace: async (workspaceGid: string, tagsCreateTagInWorkspaceRequest: TagsCreateTagInWorkspaceRequest, optPretty?: boolean, optFields?: Array<'color' | 'created_at' | 'followers' | 'followers.name' | 'name' | 'notes' | 'permalink_url' | 'workspace' | 'workspace.name'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceGid' is not null or undefined
            assertParamExists('createTagInWorkspace', 'workspaceGid', workspaceGid)
            // verify required parameter 'tagsCreateTagInWorkspaceRequest' is not null or undefined
            assertParamExists('createTagInWorkspace', 'tagsCreateTagInWorkspaceRequest', tagsCreateTagInWorkspaceRequest)
            const localVarPath = `/workspaces/{workspace_gid}/tags`
                .replace(`{${"workspace_gid"}}`, encodeURIComponent(String(workspaceGid !== undefined ? workspaceGid : `-workspace_gid-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)
            // authentication personalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            if (optPretty !== undefined) {
                localVarQueryParameter['opt_pretty'] = optPretty;
            }

            if (optFields) {
                localVarQueryParameter['opt_fields'] = optFields.join(COLLECTION_FORMATS.csv);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: tagsCreateTagInWorkspaceRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/workspaces/{workspace_gid}/tags',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(tagsCreateTagInWorkspaceRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the compact tag records for some filtered set of tags. Use one or more of the parameters provided to filter the tags returned.
         * @summary Get tags in a workspace
         * @param {string} workspaceGid Globally unique identifier for the workspace or organization.
         * @param {boolean} [optPretty] Provides “pretty” output. Provides the response in a “pretty” format. In the case of JSON this means doing proper line breaking and indentation to make it readable. This will take extra time and increase the response size so it is advisable only to use this during debugging.
         * @param {number} [limit] Results per page. The number of objects to return per page. The value must be between 1 and 100.
         * @param {string} [offset] Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. \&#39;Note: You can only pass in an offset that was returned to you via a previously paginated request.\&#39;
         * @param {Array<'color' | 'created_at' | 'followers' | 'followers.name' | 'name' | 'notes' | 'offset' | 'path' | 'permalink_url' | 'uri' | 'workspace' | 'workspace.name'>} [optFields] This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilteredTags: async (workspaceGid: string, optPretty?: boolean, limit?: number, offset?: string, optFields?: Array<'color' | 'created_at' | 'followers' | 'followers.name' | 'name' | 'notes' | 'offset' | 'path' | 'permalink_url' | 'uri' | 'workspace' | 'workspace.name'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceGid' is not null or undefined
            assertParamExists('getFilteredTags', 'workspaceGid', workspaceGid)
            const localVarPath = `/workspaces/{workspace_gid}/tags`
                .replace(`{${"workspace_gid"}}`, encodeURIComponent(String(workspaceGid !== undefined ? workspaceGid : `-workspace_gid-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)
            // authentication personalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            if (optPretty !== undefined) {
                localVarQueryParameter['opt_pretty'] = optPretty;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (optFields) {
                localVarQueryParameter['opt_fields'] = optFields.join(COLLECTION_FORMATS.csv);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/workspaces/{workspace_gid}/tags',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the complete tag record for a single tag.
         * @summary Get a tag
         * @param {string} tagGid Globally unique identifier for the tag.
         * @param {boolean} [optPretty] Provides “pretty” output. Provides the response in a “pretty” format. In the case of JSON this means doing proper line breaking and indentation to make it readable. This will take extra time and increase the response size so it is advisable only to use this during debugging.
         * @param {Array<'color' | 'created_at' | 'followers' | 'followers.name' | 'name' | 'notes' | 'permalink_url' | 'workspace' | 'workspace.name'>} [optFields] This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecord: async (tagGid: string, optPretty?: boolean, optFields?: Array<'color' | 'created_at' | 'followers' | 'followers.name' | 'name' | 'notes' | 'permalink_url' | 'workspace' | 'workspace.name'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagGid' is not null or undefined
            assertParamExists('getRecord', 'tagGid', tagGid)
            const localVarPath = `/tags/{tag_gid}`
                .replace(`{${"tag_gid"}}`, encodeURIComponent(String(tagGid !== undefined ? tagGid : `-tag_gid-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)
            // authentication personalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            if (optPretty !== undefined) {
                localVarQueryParameter['opt_pretty'] = optPretty;
            }

            if (optFields) {
                localVarQueryParameter['opt_fields'] = optFields.join(COLLECTION_FORMATS.csv);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/tags/{tag_gid}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a compact representation of all of the tags the task has.
         * @summary Get a task\'s tags
         * @param {string} taskGid The task to operate on.
         * @param {boolean} [optPretty] Provides “pretty” output. Provides the response in a “pretty” format. In the case of JSON this means doing proper line breaking and indentation to make it readable. This will take extra time and increase the response size so it is advisable only to use this during debugging.
         * @param {number} [limit] Results per page. The number of objects to return per page. The value must be between 1 and 100.
         * @param {string} [offset] Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. \&#39;Note: You can only pass in an offset that was returned to you via a previously paginated request.\&#39;
         * @param {Array<'color' | 'created_at' | 'followers' | 'followers.name' | 'name' | 'notes' | 'offset' | 'path' | 'permalink_url' | 'uri' | 'workspace' | 'workspace.name'>} [optFields] This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskTags: async (taskGid: string, optPretty?: boolean, limit?: number, offset?: string, optFields?: Array<'color' | 'created_at' | 'followers' | 'followers.name' | 'name' | 'notes' | 'offset' | 'path' | 'permalink_url' | 'uri' | 'workspace' | 'workspace.name'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskGid' is not null or undefined
            assertParamExists('getTaskTags', 'taskGid', taskGid)
            const localVarPath = `/tasks/{task_gid}/tags`
                .replace(`{${"task_gid"}}`, encodeURIComponent(String(taskGid !== undefined ? taskGid : `-task_gid-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)
            // authentication personalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            if (optPretty !== undefined) {
                localVarQueryParameter['opt_pretty'] = optPretty;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (optFields) {
                localVarQueryParameter['opt_fields'] = optFields.join(COLLECTION_FORMATS.csv);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/tasks/{task_gid}/tags',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the compact tag records for some filtered set of tags. Use one or more of the parameters provided to filter the tags returned.
         * @summary Get multiple tags
         * @param {boolean} [optPretty] Provides “pretty” output. Provides the response in a “pretty” format. In the case of JSON this means doing proper line breaking and indentation to make it readable. This will take extra time and increase the response size so it is advisable only to use this during debugging.
         * @param {number} [limit] Results per page. The number of objects to return per page. The value must be between 1 and 100.
         * @param {string} [offset] Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. \&#39;Note: You can only pass in an offset that was returned to you via a previously paginated request.\&#39;
         * @param {string} [workspace] The workspace to filter tags on.
         * @param {Array<'color' | 'created_at' | 'followers' | 'followers.name' | 'name' | 'notes' | 'offset' | 'path' | 'permalink_url' | 'uri' | 'workspace' | 'workspace.name'>} [optFields] This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFilteredTags: async (optPretty?: boolean, limit?: number, offset?: string, workspace?: string, optFields?: Array<'color' | 'created_at' | 'followers' | 'followers.name' | 'name' | 'notes' | 'offset' | 'path' | 'permalink_url' | 'uri' | 'workspace' | 'workspace.name'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)
            // authentication personalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            if (optPretty !== undefined) {
                localVarQueryParameter['opt_pretty'] = optPretty;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (workspace !== undefined) {
                localVarQueryParameter['workspace'] = workspace;
            }

            if (optFields) {
                localVarQueryParameter['opt_fields'] = optFields.join(COLLECTION_FORMATS.csv);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/tags',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A specific, existing tag can be deleted by making a DELETE request on the URL for that tag.  Returns an empty data record.
         * @summary Delete a tag
         * @param {string} tagGid Globally unique identifier for the tag.
         * @param {boolean} [optPretty] Provides “pretty” output. Provides the response in a “pretty” format. In the case of JSON this means doing proper line breaking and indentation to make it readable. This will take extra time and increase the response size so it is advisable only to use this during debugging.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTag: async (tagGid: string, optPretty?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagGid' is not null or undefined
            assertParamExists('removeTag', 'tagGid', tagGid)
            const localVarPath = `/tags/{tag_gid}`
                .replace(`{${"tag_gid"}}`, encodeURIComponent(String(tagGid !== undefined ? tagGid : `-tag_gid-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)
            // authentication personalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            if (optPretty !== undefined) {
                localVarQueryParameter['opt_pretty'] = optPretty;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/tags/{tag_gid}',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the properties of a tag. Only the fields provided in the `data` block will be updated; any unspecified fields will remain unchanged.  When using this method, it is best to specify only those fields you wish to change, or else you may overwrite changes made by another user since you last retrieved the tag.  Returns the complete updated tag record.
         * @summary Update a tag
         * @param {string} tagGid Globally unique identifier for the tag.
         * @param {boolean} [optPretty] Provides “pretty” output. Provides the response in a “pretty” format. In the case of JSON this means doing proper line breaking and indentation to make it readable. This will take extra time and increase the response size so it is advisable only to use this during debugging.
         * @param {Array<'color' | 'created_at' | 'followers' | 'followers.name' | 'name' | 'notes' | 'permalink_url' | 'workspace' | 'workspace.name'>} [optFields] This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTagRecord: async (tagGid: string, optPretty?: boolean, optFields?: Array<'color' | 'created_at' | 'followers' | 'followers.name' | 'name' | 'notes' | 'permalink_url' | 'workspace' | 'workspace.name'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagGid' is not null or undefined
            assertParamExists('updateTagRecord', 'tagGid', tagGid)
            const localVarPath = `/tags/{tag_gid}`
                .replace(`{${"tag_gid"}}`, encodeURIComponent(String(tagGid !== undefined ? tagGid : `-tag_gid-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oauth2", [], configuration)
            // authentication personalAccessToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)
            if (optPretty !== undefined) {
                localVarQueryParameter['opt_pretty'] = optPretty;
            }

            if (optFields) {
                localVarQueryParameter['opt_fields'] = optFields.join(COLLECTION_FORMATS.csv);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/tags/{tag_gid}',
                httpMethod: 'PUT'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagsApi - functional programming interface
 * @export
 */
export const TagsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new tag in a workspace or organization.  Every tag is required to be created in a specific workspace or organization, and this cannot be changed once set. Note that you can use the workspace parameter regardless of whether or not it is an organization.  Returns the full record of the newly created tag.
         * @summary Create a tag
         * @param {TagsApiCreateNewTagRecordRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNewTagRecord(requestParameters: TagsApiCreateNewTagRecordRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagsCreateNewTagRecordResponse>> {
            const tagsCreateNewTagRecordRequest: TagsCreateNewTagRecordRequest = {
                data: requestParameters.data
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNewTagRecord(tagsCreateNewTagRecordRequest, requestParameters.optPretty, requestParameters.optFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new tag in a workspace or organization.  Every tag is required to be created in a specific workspace or organization, and this cannot be changed once set. Note that you can use the workspace parameter regardless of whether or not it is an organization.  Returns the full record of the newly created tag.
         * @summary Create a tag in a workspace
         * @param {TagsApiCreateTagInWorkspaceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTagInWorkspace(requestParameters: TagsApiCreateTagInWorkspaceRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagsCreateTagInWorkspaceResponse>> {
            const tagsCreateTagInWorkspaceRequest: TagsCreateTagInWorkspaceRequest = {
                data: requestParameters.data
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTagInWorkspace(requestParameters.workspaceGid, tagsCreateTagInWorkspaceRequest, requestParameters.optPretty, requestParameters.optFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the compact tag records for some filtered set of tags. Use one or more of the parameters provided to filter the tags returned.
         * @summary Get tags in a workspace
         * @param {TagsApiGetFilteredTagsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFilteredTags(requestParameters: TagsApiGetFilteredTagsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagsGetFilteredTagsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFilteredTags(requestParameters.workspaceGid, requestParameters.optPretty, requestParameters.limit, requestParameters.offset, requestParameters.optFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the complete tag record for a single tag.
         * @summary Get a tag
         * @param {TagsApiGetRecordRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecord(requestParameters: TagsApiGetRecordRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagsGetRecordResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecord(requestParameters.tagGid, requestParameters.optPretty, requestParameters.optFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a compact representation of all of the tags the task has.
         * @summary Get a task\'s tags
         * @param {TagsApiGetTaskTagsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTaskTags(requestParameters: TagsApiGetTaskTagsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagsGetTaskTagsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTaskTags(requestParameters.taskGid, requestParameters.optPretty, requestParameters.limit, requestParameters.offset, requestParameters.optFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the compact tag records for some filtered set of tags. Use one or more of the parameters provided to filter the tags returned.
         * @summary Get multiple tags
         * @param {TagsApiListFilteredTagsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFilteredTags(requestParameters: TagsApiListFilteredTagsRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagsListFilteredTagsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFilteredTags(requestParameters.optPretty, requestParameters.limit, requestParameters.offset, requestParameters.workspace, requestParameters.optFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A specific, existing tag can be deleted by making a DELETE request on the URL for that tag.  Returns an empty data record.
         * @summary Delete a tag
         * @param {TagsApiRemoveTagRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeTag(requestParameters: TagsApiRemoveTagRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagsRemoveTagResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeTag(requestParameters.tagGid, requestParameters.optPretty, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the properties of a tag. Only the fields provided in the `data` block will be updated; any unspecified fields will remain unchanged.  When using this method, it is best to specify only those fields you wish to change, or else you may overwrite changes made by another user since you last retrieved the tag.  Returns the complete updated tag record.
         * @summary Update a tag
         * @param {TagsApiUpdateTagRecordRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTagRecord(requestParameters: TagsApiUpdateTagRecordRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagsUpdateTagRecordResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTagRecord(requestParameters.tagGid, requestParameters.optPretty, requestParameters.optFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TagsApi - factory interface
 * @export
 */
export const TagsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagsApiFp(configuration)
    return {
        /**
         * Creates a new tag in a workspace or organization.  Every tag is required to be created in a specific workspace or organization, and this cannot be changed once set. Note that you can use the workspace parameter regardless of whether or not it is an organization.  Returns the full record of the newly created tag.
         * @summary Create a tag
         * @param {TagsApiCreateNewTagRecordRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewTagRecord(requestParameters: TagsApiCreateNewTagRecordRequest, options?: AxiosRequestConfig): AxiosPromise<TagsCreateNewTagRecordResponse> {
            return localVarFp.createNewTagRecord(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new tag in a workspace or organization.  Every tag is required to be created in a specific workspace or organization, and this cannot be changed once set. Note that you can use the workspace parameter regardless of whether or not it is an organization.  Returns the full record of the newly created tag.
         * @summary Create a tag in a workspace
         * @param {TagsApiCreateTagInWorkspaceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTagInWorkspace(requestParameters: TagsApiCreateTagInWorkspaceRequest, options?: AxiosRequestConfig): AxiosPromise<TagsCreateTagInWorkspaceResponse> {
            return localVarFp.createTagInWorkspace(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the compact tag records for some filtered set of tags. Use one or more of the parameters provided to filter the tags returned.
         * @summary Get tags in a workspace
         * @param {TagsApiGetFilteredTagsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilteredTags(requestParameters: TagsApiGetFilteredTagsRequest, options?: AxiosRequestConfig): AxiosPromise<TagsGetFilteredTagsResponse> {
            return localVarFp.getFilteredTags(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the complete tag record for a single tag.
         * @summary Get a tag
         * @param {TagsApiGetRecordRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecord(requestParameters: TagsApiGetRecordRequest, options?: AxiosRequestConfig): AxiosPromise<TagsGetRecordResponse> {
            return localVarFp.getRecord(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a compact representation of all of the tags the task has.
         * @summary Get a task\'s tags
         * @param {TagsApiGetTaskTagsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskTags(requestParameters: TagsApiGetTaskTagsRequest, options?: AxiosRequestConfig): AxiosPromise<TagsGetTaskTagsResponse> {
            return localVarFp.getTaskTags(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the compact tag records for some filtered set of tags. Use one or more of the parameters provided to filter the tags returned.
         * @summary Get multiple tags
         * @param {TagsApiListFilteredTagsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFilteredTags(requestParameters: TagsApiListFilteredTagsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<TagsListFilteredTagsResponse> {
            return localVarFp.listFilteredTags(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * A specific, existing tag can be deleted by making a DELETE request on the URL for that tag.  Returns an empty data record.
         * @summary Delete a tag
         * @param {TagsApiRemoveTagRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTag(requestParameters: TagsApiRemoveTagRequest, options?: AxiosRequestConfig): AxiosPromise<TagsRemoveTagResponse> {
            return localVarFp.removeTag(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the properties of a tag. Only the fields provided in the `data` block will be updated; any unspecified fields will remain unchanged.  When using this method, it is best to specify only those fields you wish to change, or else you may overwrite changes made by another user since you last retrieved the tag.  Returns the complete updated tag record.
         * @summary Update a tag
         * @param {TagsApiUpdateTagRecordRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTagRecord(requestParameters: TagsApiUpdateTagRecordRequest, options?: AxiosRequestConfig): AxiosPromise<TagsUpdateTagRecordResponse> {
            return localVarFp.updateTagRecord(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createNewTagRecord operation in TagsApi.
 * @export
 * @interface TagsApiCreateNewTagRecordRequest
 */
export type TagsApiCreateNewTagRecordRequest = {
    
    /**
    * Provides “pretty” output. Provides the response in a “pretty” format. In the case of JSON this means doing proper line breaking and indentation to make it readable. This will take extra time and increase the response size so it is advisable only to use this during debugging.
    * @type {boolean}
    * @memberof TagsApiCreateNewTagRecord
    */
    readonly optPretty?: boolean
    
    /**
    * This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
    * @type {Array<'color' | 'created_at' | 'followers' | 'followers.name' | 'name' | 'notes' | 'permalink_url' | 'workspace' | 'workspace.name'>}
    * @memberof TagsApiCreateNewTagRecord
    */
    readonly optFields?: Array<'color' | 'created_at' | 'followers' | 'followers.name' | 'name' | 'notes' | 'permalink_url' | 'workspace' | 'workspace.name'>
    
} & TagsCreateNewTagRecordRequest

/**
 * Request parameters for createTagInWorkspace operation in TagsApi.
 * @export
 * @interface TagsApiCreateTagInWorkspaceRequest
 */
export type TagsApiCreateTagInWorkspaceRequest = {
    
    /**
    * Globally unique identifier for the workspace or organization.
    * @type {string}
    * @memberof TagsApiCreateTagInWorkspace
    */
    readonly workspaceGid: string
    
    /**
    * Provides “pretty” output. Provides the response in a “pretty” format. In the case of JSON this means doing proper line breaking and indentation to make it readable. This will take extra time and increase the response size so it is advisable only to use this during debugging.
    * @type {boolean}
    * @memberof TagsApiCreateTagInWorkspace
    */
    readonly optPretty?: boolean
    
    /**
    * This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
    * @type {Array<'color' | 'created_at' | 'followers' | 'followers.name' | 'name' | 'notes' | 'permalink_url' | 'workspace' | 'workspace.name'>}
    * @memberof TagsApiCreateTagInWorkspace
    */
    readonly optFields?: Array<'color' | 'created_at' | 'followers' | 'followers.name' | 'name' | 'notes' | 'permalink_url' | 'workspace' | 'workspace.name'>
    
} & TagsCreateTagInWorkspaceRequest

/**
 * Request parameters for getFilteredTags operation in TagsApi.
 * @export
 * @interface TagsApiGetFilteredTagsRequest
 */
export type TagsApiGetFilteredTagsRequest = {
    
    /**
    * Globally unique identifier for the workspace or organization.
    * @type {string}
    * @memberof TagsApiGetFilteredTags
    */
    readonly workspaceGid: string
    
    /**
    * Provides “pretty” output. Provides the response in a “pretty” format. In the case of JSON this means doing proper line breaking and indentation to make it readable. This will take extra time and increase the response size so it is advisable only to use this during debugging.
    * @type {boolean}
    * @memberof TagsApiGetFilteredTags
    */
    readonly optPretty?: boolean
    
    /**
    * Results per page. The number of objects to return per page. The value must be between 1 and 100.
    * @type {number}
    * @memberof TagsApiGetFilteredTags
    */
    readonly limit?: number
    
    /**
    * Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. \'Note: You can only pass in an offset that was returned to you via a previously paginated request.\'
    * @type {string}
    * @memberof TagsApiGetFilteredTags
    */
    readonly offset?: string
    
    /**
    * This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
    * @type {Array<'color' | 'created_at' | 'followers' | 'followers.name' | 'name' | 'notes' | 'offset' | 'path' | 'permalink_url' | 'uri' | 'workspace' | 'workspace.name'>}
    * @memberof TagsApiGetFilteredTags
    */
    readonly optFields?: Array<'color' | 'created_at' | 'followers' | 'followers.name' | 'name' | 'notes' | 'offset' | 'path' | 'permalink_url' | 'uri' | 'workspace' | 'workspace.name'>
    
}

/**
 * Request parameters for getRecord operation in TagsApi.
 * @export
 * @interface TagsApiGetRecordRequest
 */
export type TagsApiGetRecordRequest = {
    
    /**
    * Globally unique identifier for the tag.
    * @type {string}
    * @memberof TagsApiGetRecord
    */
    readonly tagGid: string
    
    /**
    * Provides “pretty” output. Provides the response in a “pretty” format. In the case of JSON this means doing proper line breaking and indentation to make it readable. This will take extra time and increase the response size so it is advisable only to use this during debugging.
    * @type {boolean}
    * @memberof TagsApiGetRecord
    */
    readonly optPretty?: boolean
    
    /**
    * This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
    * @type {Array<'color' | 'created_at' | 'followers' | 'followers.name' | 'name' | 'notes' | 'permalink_url' | 'workspace' | 'workspace.name'>}
    * @memberof TagsApiGetRecord
    */
    readonly optFields?: Array<'color' | 'created_at' | 'followers' | 'followers.name' | 'name' | 'notes' | 'permalink_url' | 'workspace' | 'workspace.name'>
    
}

/**
 * Request parameters for getTaskTags operation in TagsApi.
 * @export
 * @interface TagsApiGetTaskTagsRequest
 */
export type TagsApiGetTaskTagsRequest = {
    
    /**
    * The task to operate on.
    * @type {string}
    * @memberof TagsApiGetTaskTags
    */
    readonly taskGid: string
    
    /**
    * Provides “pretty” output. Provides the response in a “pretty” format. In the case of JSON this means doing proper line breaking and indentation to make it readable. This will take extra time and increase the response size so it is advisable only to use this during debugging.
    * @type {boolean}
    * @memberof TagsApiGetTaskTags
    */
    readonly optPretty?: boolean
    
    /**
    * Results per page. The number of objects to return per page. The value must be between 1 and 100.
    * @type {number}
    * @memberof TagsApiGetTaskTags
    */
    readonly limit?: number
    
    /**
    * Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. \'Note: You can only pass in an offset that was returned to you via a previously paginated request.\'
    * @type {string}
    * @memberof TagsApiGetTaskTags
    */
    readonly offset?: string
    
    /**
    * This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
    * @type {Array<'color' | 'created_at' | 'followers' | 'followers.name' | 'name' | 'notes' | 'offset' | 'path' | 'permalink_url' | 'uri' | 'workspace' | 'workspace.name'>}
    * @memberof TagsApiGetTaskTags
    */
    readonly optFields?: Array<'color' | 'created_at' | 'followers' | 'followers.name' | 'name' | 'notes' | 'offset' | 'path' | 'permalink_url' | 'uri' | 'workspace' | 'workspace.name'>
    
}

/**
 * Request parameters for listFilteredTags operation in TagsApi.
 * @export
 * @interface TagsApiListFilteredTagsRequest
 */
export type TagsApiListFilteredTagsRequest = {
    
    /**
    * Provides “pretty” output. Provides the response in a “pretty” format. In the case of JSON this means doing proper line breaking and indentation to make it readable. This will take extra time and increase the response size so it is advisable only to use this during debugging.
    * @type {boolean}
    * @memberof TagsApiListFilteredTags
    */
    readonly optPretty?: boolean
    
    /**
    * Results per page. The number of objects to return per page. The value must be between 1 and 100.
    * @type {number}
    * @memberof TagsApiListFilteredTags
    */
    readonly limit?: number
    
    /**
    * Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. \'Note: You can only pass in an offset that was returned to you via a previously paginated request.\'
    * @type {string}
    * @memberof TagsApiListFilteredTags
    */
    readonly offset?: string
    
    /**
    * The workspace to filter tags on.
    * @type {string}
    * @memberof TagsApiListFilteredTags
    */
    readonly workspace?: string
    
    /**
    * This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
    * @type {Array<'color' | 'created_at' | 'followers' | 'followers.name' | 'name' | 'notes' | 'offset' | 'path' | 'permalink_url' | 'uri' | 'workspace' | 'workspace.name'>}
    * @memberof TagsApiListFilteredTags
    */
    readonly optFields?: Array<'color' | 'created_at' | 'followers' | 'followers.name' | 'name' | 'notes' | 'offset' | 'path' | 'permalink_url' | 'uri' | 'workspace' | 'workspace.name'>
    
}

/**
 * Request parameters for removeTag operation in TagsApi.
 * @export
 * @interface TagsApiRemoveTagRequest
 */
export type TagsApiRemoveTagRequest = {
    
    /**
    * Globally unique identifier for the tag.
    * @type {string}
    * @memberof TagsApiRemoveTag
    */
    readonly tagGid: string
    
    /**
    * Provides “pretty” output. Provides the response in a “pretty” format. In the case of JSON this means doing proper line breaking and indentation to make it readable. This will take extra time and increase the response size so it is advisable only to use this during debugging.
    * @type {boolean}
    * @memberof TagsApiRemoveTag
    */
    readonly optPretty?: boolean
    
}

/**
 * Request parameters for updateTagRecord operation in TagsApi.
 * @export
 * @interface TagsApiUpdateTagRecordRequest
 */
export type TagsApiUpdateTagRecordRequest = {
    
    /**
    * Globally unique identifier for the tag.
    * @type {string}
    * @memberof TagsApiUpdateTagRecord
    */
    readonly tagGid: string
    
    /**
    * Provides “pretty” output. Provides the response in a “pretty” format. In the case of JSON this means doing proper line breaking and indentation to make it readable. This will take extra time and increase the response size so it is advisable only to use this during debugging.
    * @type {boolean}
    * @memberof TagsApiUpdateTagRecord
    */
    readonly optPretty?: boolean
    
    /**
    * This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
    * @type {Array<'color' | 'created_at' | 'followers' | 'followers.name' | 'name' | 'notes' | 'permalink_url' | 'workspace' | 'workspace.name'>}
    * @memberof TagsApiUpdateTagRecord
    */
    readonly optFields?: Array<'color' | 'created_at' | 'followers' | 'followers.name' | 'name' | 'notes' | 'permalink_url' | 'workspace' | 'workspace.name'>
    
}

/**
 * TagsApiGenerated - object-oriented interface
 * @export
 * @class TagsApiGenerated
 * @extends {BaseAPI}
 */
export class TagsApiGenerated extends BaseAPI {
    /**
     * Creates a new tag in a workspace or organization.  Every tag is required to be created in a specific workspace or organization, and this cannot be changed once set. Note that you can use the workspace parameter regardless of whether or not it is an organization.  Returns the full record of the newly created tag.
     * @summary Create a tag
     * @param {TagsApiCreateNewTagRecordRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApiGenerated
     */
    public createNewTagRecord(requestParameters: TagsApiCreateNewTagRecordRequest, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).createNewTagRecord(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new tag in a workspace or organization.  Every tag is required to be created in a specific workspace or organization, and this cannot be changed once set. Note that you can use the workspace parameter regardless of whether or not it is an organization.  Returns the full record of the newly created tag.
     * @summary Create a tag in a workspace
     * @param {TagsApiCreateTagInWorkspaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApiGenerated
     */
    public createTagInWorkspace(requestParameters: TagsApiCreateTagInWorkspaceRequest, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).createTagInWorkspace(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the compact tag records for some filtered set of tags. Use one or more of the parameters provided to filter the tags returned.
     * @summary Get tags in a workspace
     * @param {TagsApiGetFilteredTagsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApiGenerated
     */
    public getFilteredTags(requestParameters: TagsApiGetFilteredTagsRequest, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).getFilteredTags(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the complete tag record for a single tag.
     * @summary Get a tag
     * @param {TagsApiGetRecordRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApiGenerated
     */
    public getRecord(requestParameters: TagsApiGetRecordRequest, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).getRecord(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a compact representation of all of the tags the task has.
     * @summary Get a task\'s tags
     * @param {TagsApiGetTaskTagsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApiGenerated
     */
    public getTaskTags(requestParameters: TagsApiGetTaskTagsRequest, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).getTaskTags(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the compact tag records for some filtered set of tags. Use one or more of the parameters provided to filter the tags returned.
     * @summary Get multiple tags
     * @param {TagsApiListFilteredTagsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApiGenerated
     */
    public listFilteredTags(requestParameters: TagsApiListFilteredTagsRequest = {}, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).listFilteredTags(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A specific, existing tag can be deleted by making a DELETE request on the URL for that tag.  Returns an empty data record.
     * @summary Delete a tag
     * @param {TagsApiRemoveTagRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApiGenerated
     */
    public removeTag(requestParameters: TagsApiRemoveTagRequest, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).removeTag(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the properties of a tag. Only the fields provided in the `data` block will be updated; any unspecified fields will remain unchanged.  When using this method, it is best to specify only those fields you wish to change, or else you may overwrite changes made by another user since you last retrieved the tag.  Returns the complete updated tag record.
     * @summary Update a tag
     * @param {TagsApiUpdateTagRecordRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApiGenerated
     */
    public updateTagRecord(requestParameters: TagsApiUpdateTagRecordRequest, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).updateTagRecord(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
